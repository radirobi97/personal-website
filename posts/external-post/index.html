<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta http-equiv=content-security-policy content="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net/; form-action 'self'; frame-src 'self'; img-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/ https://cdn.jsdelivr.net/; script-src 'self' 'unsafe-inline' https://www.google-analytics.com; prefetch-src 'self'; connect-src 'self' https://www.google-analytics.com;"><meta name=author content="Robert Radi"><meta name=description content="Just to be on the same page Kubernetes is all about containerization. Every container is placed inside a POD. The scheduler places the PODs onto different nodes. Nodes are the physical/virutal machines. A POD can have one ore more replicas by using ReplicaSet. There are no guarantees for that the PODs of the same ReplicaSet will be hosted on the same node.
How does the external traffic reach the destination POD?"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Effect of externalTrafficPolicy on Kubernetes services"><meta name=twitter:description content="Just to be on the same page Kubernetes is all about containerization. Every container is placed inside a POD. The scheduler places the PODs onto different nodes. Nodes are the physical/virutal machines. A POD can have one ore more replicas by using ReplicaSet. There are no guarantees for that the PODs of the same ReplicaSet will be hosted on the same node.
How does the external traffic reach the destination POD?"><meta property="og:title" content="Effect of externalTrafficPolicy on Kubernetes services"><meta property="og:description" content="Just to be on the same page Kubernetes is all about containerization. Every container is placed inside a POD. The scheduler places the PODs onto different nodes. Nodes are the physical/virutal machines. A POD can have one ore more replicas by using ReplicaSet. There are no guarantees for that the PODs of the same ReplicaSet will be hosted on the same node.
How does the external traffic reach the destination POD?"><meta property="og:type" content="article"><meta property="og:url" content="https://radirobi97.github.io/personal-website/posts/external-post/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-03T00:00:00+00:00"><meta property="article:modified_time" content="2020-12-03T00:00:00+00:00"><title>Effect of externalTrafficPolicy on Kubernetes services · robertradi</title><link rel=canonical href=https://radirobi97.github.io/personal-website/posts/external-post/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/personal-website/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen><link rel=stylesheet href=/personal-website/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/personal-website/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/personal-website/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/personal-website/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/personal-website/images/apple-touch-icon.png><meta name=generator content="Hugo 0.100.2"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/personal-website>robertradi</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/personal-website/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/personal-website/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/personal-website/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=/personal-website/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://radirobi97.github.io/personal-website/posts/external-post/>Effect of externalTrafficPolicy on Kubernetes services</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2020-12-03T00:00:00Z>December 3, 2020</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
4-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/personal-website/categories/kubernetes/>kubernetes</a>
<span class=separator>•</span>
<a href=/personal-website/categories/in-depth/>in-depth</a></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/personal-website/tags/kubernetes/>kubernetes</a></span>
<span class=separator>•</span>
<span class=tag><a href=/personal-website/tags/service/>service</a></span></div></div></header><div><h2 id=just-to-be-on-the-same-page>Just to be on the same page
<a class=heading-link href=#just-to-be-on-the-same-page><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Kubernetes is all about containerization. Every container is placed inside a POD. The scheduler places the PODs onto different nodes. Nodes are the physical/virutal machines.
A POD can have one ore more replicas by using ReplicaSet. There are no guarantees for that the PODs of the same ReplicaSet will be hosted on the same node.</p><h2 id=how-does-the-external-traffic-reach-the-destination-pod>How does the external traffic reach the destination POD?
<a class=heading-link href=#how-does-the-external-traffic-reach-the-destination-pod><i class="fa fa-link" aria-hidden=true></i></a></h2><p>First of all the traffic hits one of the nodes. This node will route the traffic to the target POD via kube-proxy. However, this POD could be on the node where the traffic came in, or could be on a different node. This is where ExternalTrafficPolicy comes into picture.</p><p>The offical documentation says: ExternalTrafficPolicy denotes if this Service desires to route external traffic to node-local (only that node as the incoming traffic) or cluster-wide endpoints. Meaning, using this parameter we can decide whether we want to allow this &ldquo;cross-node&rdquo; routing. ExternalTrafficPolicy can be on of the followings:</p><ul><li><strong>Cluster</strong>: The traffic hits one of the nodes, however the target POD is on a different node. Using Cluster mode as ExternalTrafficPolicy makes possible for kube-proxy to forward the traffic to a different node. See this on the figure below.</li></ul><p><img src=/personal-website/images/traffic_flow.png#center alt=traffic-flow></p><ul><li><strong>Local</strong>: The traffic hits one of the nodes. In case of Local as ExternalTrafficPolicy kube proxy is only able to route the traffic locally. Meaning, only to PODs which are on the same node.</li></ul><p><img src=/personal-website/images/local_external.png#center alt=traffic-flow></p><h2 id=comparison-of-local-and-cluster>Comparison of Local and Cluster
<a class=heading-link href=#comparison-of-local-and-cluster><i class="fa fa-link" aria-hidden=true></i></a></h2><h4 id=externaltrafficpolicy-cluster>externalTrafficPolicy: Cluster
<a class=heading-link href=#externaltrafficpolicy-cluster><i class="fa fa-link" aria-hidden=true></i></a></h4><p>This is the default value for services. It provides an equally distributed traffic between PODs regardless of where the PODs are located. However, this method could add extra network hops to the traffic if the target POD is on a different node.
Also this mechanism introduces the usage of SNAT-ting (source network address translation). SNAT results in loss of IP of the client.</p><p>You probably ask why SNAT is needed? Lets take what happens if we use only DNAT. Lets image a scenario where the Load Balacner forwards the traffic to a node however the target POD is on a different node. Thats why we use Cluster as externalTrafficPolicy. Here is the flow:</p><p><img src=/personal-website/images/without_snat.png#center alt=traffic-without-snat></p><ol><li>Client hits the Load Balancer and the LB will route the traffic to one of the nodes.</li><li>On the node, kube-proxy handles the incoming traffic, modifes the destination in the packet -this is the DNAT - and forwards the packet to the other node. On this node kube-proxy forwards the traffic to the destination POD (on the picture above the connection arrow is direct between the first node and the POD, however the traffic goes through the kube-proxy of the second node as well.)</li><li>The target POD recieves the packet, and tries to answer for that. It sets the SRC as its IP and the destination will be the client.</li><li>Because the packet is from the POD to the client it will be NAT-ed to the internet. However, this packet will be dropped. Why? Because the client sent a packet to the load balancer, it didnt send the packet to the VM or this POD. So, the TCP session is not able to complete.</li></ol><p>Let&rsquo;s see how SNAT-ting solves this problem. The figure is almost the same. The difference, when the packet reaches the first VM we do a second NAT, the SNAT. The source will be the IP of the node, the destination will be the pod.</p><p><img src=/personal-website/images/with_snat.png#center alt=traffic-with-snat></p><ol start=4><li>This time the TCP session is able to complete, because the source and destination matches.</li><li>The traffic goes back to the first node, where the node will unnat the packet twice. The result of this unNAT is the packet where the source is the LB and the DST is the client.</li></ol><p>The obvious drawback of the SNAT is that the target POD is not able to see the client&rsquo;s IP address thats why we want to use sometimes the Local settings.</p><h4 id=externaltrafficpolicy-local>externalTrafficPolicy: Local
<a class=heading-link href=#externaltrafficpolicy-local><i class="fa fa-link" aria-hidden=true></i></a></h4><p>In this case, kube-proxy will proxies the traffic only to pods that exist on the same node (local) as opposed to every pod regardless of where it was placed (Cluster). It ensures that the target POD will be able to see the client&rsquo;s IP address (because we dont have to use SNAT) and will be no extra network hops.</p><p>The obvious drawback using the “Local” external traffic policy, is that traffic to our application may be imbalanced. See this on the following picture.</p><p><img src=/personal-website/images/imbalance.png#center alt=traffic-imbalanced></p><p>The Cloud Loadbalance is only aware of Nodes, not PODs so it wont know how many PODs are on the given nodes. The cloud LB will route the traffic between the nodes equally.</p><p>If our workload has a much more pods, and those PODs are distributed on the different node, the imbalance problem will be less meaningful. See below:</p><p><img src=/personal-website/images/balanced.png#center alt=traffic-imbalanced></p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2022
Robert Radi
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/personal-website/js/coder.min.faf284b268283ca4c276087ba3ee2dc8bd9c8e95dde688c2f16efaa82c4884be.js integrity="sha256-+vKEsmgoPKTCdgh7o+4tyL2cjpXd5ojC8W76qCxIhL4="></script></body></html>